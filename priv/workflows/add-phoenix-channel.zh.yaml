# BMAD 工作流：添加 Phoenix Channel
# 在向 Phoenix 添加 WebSocket 实时通信时使用此工作流

name: 添加 Phoenix Channel
description: 使用 Phoenix Channels 实现实时功能的完整工作流
type: feature
framework: phoenix_channels
complexity: medium-high
agents_involved:
  - phoenix-expert
  - elixir-dev
  - elixir-qa

prerequisites:
  - 已安装支持 Channel 的 Phoenix
  - 理解 WebSocket 协议
  - 熟悉客户端 JavaScript
  - 已定义实时需求

steps:
  - name: 规划 Channel 架构
    agent: phoenix-expert
    duration: 30min - 1hr
    questions:
      - 需要哪些实时功能？
      - 用户将加入哪些主题/房间？
      - 将广播哪些事件？
      - 是否需要在线状态跟踪？
      - 身份验证策略是什么？
      - 预期的并发连接数是多少？
    deliverable: Channel 架构图

  - name: 生成 Channel
    agent: elixir-dev
    duration: 15min
    command: |
      mix phx.gen.channel Room

    generates: |
      - lib/my_app_web/channels/room_channel.ex
      - test/my_app_web/channels/room_channel_test.exs
      - 更新 lib/my_app_web/channels/user_socket.ex

  - name: 配置 Socket
    agent: phoenix-expert
    duration: 15-30min
    tasks:
      - 使用 channels 配置 user_socket.ex
      - 如需要添加身份验证
      - 设置 socket assigns
    pattern: |
      defmodule MyAppWeb.UserSocket do
        use Phoenix.Socket

        # Channels
        channel "room:*", MyAppWeb.RoomChannel
        channel "chat:*", MyAppWeb.ChatChannel
        channel "user:*", MyAppWeb.UserChannel

        @impl true
        def connect(%{"token" => token}, socket, _connect_info) do
          # 验证用户
          case Phoenix.Token.verify(socket, "user socket", token, max_age: 86400) do
            {:ok, user_id} ->
              socket = assign(socket, :current_user_id, user_id)
              {:ok, socket}

            {:error, _reason} ->
              :error
          end
        end

        def connect(_params, _socket, _connect_info), do: :error

        @impl true
        def id(socket), do: "user_socket:#{socket.assigns.current_user_id}"
      end

      # 在 endpoint.ex 中
      socket "/socket", MyAppWeb.UserSocket,
        websocket: true,
        longpoll: false

  - name: 实现 Channel
    agent: phoenix-expert
    duration: 1-3hrs
    tasks:
      - 实现 join/3 进行授权
      - 为传入消息添加 handle_in
      - 实现 handle_out 处理传出广播
      - 如需要添加在线状态跟踪
    pattern: |
      defmodule MyAppWeb.RoomChannel do
        use MyAppWeb, :channel

        alias MyApp.Chat
        alias MyAppWeb.Presence

        @impl true
        def join("room:" <> room_id, _params, socket) do
          # 授权检查
          user_id = socket.assigns.current_user_id

          if authorized?(user_id, room_id) do
            send(self(), :after_join)
            {:ok, assign(socket, :room_id, room_id)}
          else
            {:error, %{reason: "unauthorized"}}
          end
        end

        @impl true
        def handle_info(:after_join, socket) do
          # 加载最近的消息
          room_id = socket.assigns.room_id
          messages = Chat.recent_messages(room_id, 50)

          push(socket, "messages:loaded", %{messages: messages})

          # 跟踪在线状态
          {:ok, _} = Presence.track(socket, socket.assigns.current_user_id, %{
            online_at: inspect(System.system_time(:second))
          })

          push(socket, "presence_state", Presence.list(socket))
          {:noreply, socket}
        end

        @impl true
        def handle_in("message:new", %{"text" => text}, socket) do
          room_id = socket.assigns.room_id
          user_id = socket.assigns.current_user_id

          case Chat.create_message(room_id, user_id, text) do
            {:ok, message} ->
              # 广播给房间中的所有用户
              broadcast!(socket, "message:new", %{
                id: message.id,
                text: message.text,
                user_id: message.user_id,
                inserted_at: message.inserted_at
              })

              {:reply, :ok, socket}

            {:error, changeset} ->
              {:reply, {:error, %{errors: translate_errors(changeset)}}, socket}
          end
        end

        @impl true
        def handle_in("typing:start", _params, socket) do
          broadcast_from!(socket, "typing:start", %{
            user_id: socket.assigns.current_user_id
          })

          {:noreply, socket}
        end

        @impl true
        def handle_in("typing:stop", _params, socket) do
          broadcast_from!(socket, "typing:stop", %{
            user_id: socket.assigns.current_user_id
          })

          {:noreply, socket}
        end

        # 辅助函数

        defp authorized?(user_id, room_id) do
          Chat.user_can_access_room?(user_id, room_id)
        end

        defp translate_errors(changeset) do
          Ecto.Changeset.traverse_errors(changeset, fn {msg, opts} ->
            Regex.replace(~r"%{(\w+)}", msg, fn _, key ->
              opts |> Keyword.get(String.to_existing_atom(key), key) |> to_string()
            end)
          end)
        end
      end

  - name: 添加在线状态跟踪（如需要）
    agent: phoenix-expert
    duration: 30min - 1hr
    tasks:
      - 创建 Presence 模块
      - 在 channel 中跟踪用户在线状态
      - 处理在线状态差异事件
    pattern: |
      # 创建在线状态模块
      defmodule MyAppWeb.Presence do
        use Phoenix.Presence,
          otp_app: :my_app,
          pubsub_server: MyApp.PubSub
      end

      # 添加到 application.ex 中的监督树
      children = [
        MyApp.Repo,
        MyAppWeb.Presence
      ]

      # 在 channel 中
      def handle_info(:after_join, socket) do
        {:ok, _} = Presence.track(socket, socket.assigns.current_user_id, %{
          online_at: inspect(System.system_time(:second)),
          username: socket.assigns.username
        })

        push(socket, "presence_state", Presence.list(socket))
        {:noreply, socket}
      end

  - name: 实现客户端 JavaScript
    agent: elixir-dev
    duration: 1-2hrs
    tasks:
      - 设置 Phoenix Socket 连接
      - 使用身份验证加入 channel
      - 处理传入事件
      - 发送传出事件
      - 处理连接错误
    pattern: |
      // 在 assets/js/user_socket.js 中
      import {Socket} from "phoenix"

      let socket = new Socket("/socket", {
        params: {token: window.userToken},
        logger: (kind, msg, data) => { console.log(`${kind}: ${msg}`, data) }
      })

      socket.connect()

      // 加入 channel
      let channel = socket.channel("room:lobby", {})

      channel.on("messages:loaded", payload => {
        console.log("消息已加载:", payload.messages)
        renderMessages(payload.messages)
      })

      channel.on("message:new", payload => {
        console.log("新消息:", payload)
        appendMessage(payload)
      })

      channel.on("typing:start", payload => {
        console.log("用户正在输入:", payload.user_id)
        showTypingIndicator(payload.user_id)
      })

      channel.on("typing:stop", payload => {
        hideTypingIndicator(payload.user_id)
      })

      channel.on("presence_state", state => {
        console.log("初始在线状态:", state)
        renderPresence(state)
      })

      channel.on("presence_diff", diff => {
        console.log("在线状态差异:", diff)
        updatePresence(diff)
      })

      channel.join()
        .receive("ok", resp => { console.log("成功加入", resp) })
        .receive("error", resp => { console.log("无法加入", resp) })

      // 发送消息
      document.querySelector("#send-button").addEventListener("click", e => {
        let input = document.querySelector("#message-input")
        let text = input.value

        channel.push("message:new", {text: text})
          .receive("ok", () => {
            input.value = ""
          })
          .receive("error", resp => {
            console.error("发送消息出错:", resp)
          })
      })

      // 输入指示器
      let typingTimer
      document.querySelector("#message-input").addEventListener("keyup", e => {
        clearTimeout(typingTimer)

        channel.push("typing:start", {})

        typingTimer = setTimeout(() => {
          channel.push("typing:stop", {})
        }, 1000)
      })

  - name: 处理来自 Context 的广播
    agent: elixir-dev
    duration: 30min - 1hr
    tasks:
      - 在变更后广播事件
      - 向特定用户发送目标消息
      - 更新所有连接的客户端
    pattern: |
      # 在 Chat context 中
      def create_message(room_id, user_id, text) do
        %Message{}
        |> Message.changeset(%{
          room_id: room_id,
          user_id: user_id,
          text: text
        })
        |> Repo.insert()
        |> broadcast_message(:message_created, room_id)
      end

      defp broadcast_message({:ok, message}, event, room_id) do
        MyAppWeb.Endpoint.broadcast!(
          "room:#{room_id}",
          Atom.to_string(event),
          %{
            id: message.id,
            text: message.text,
            user_id: message.user_id,
            inserted_at: message.inserted_at
          }
        )

        {:ok, message}
      end

      defp broadcast_message(error, _event, _room_id), do: error

      # 发送给特定用户
      def notify_user(user_id, notification) do
        MyAppWeb.Endpoint.broadcast!(
          "user:#{user_id}",
          "notification:new",
          notification
        )
      end

  - name: 添加速率限制
    agent: elixir-dev
    duration: 30min - 1hr
    tasks:
      - 防止消息泛滥
      - 限制连接尝试
      - 跟踪用户活动
    pattern: |
      defmodule MyAppWeb.RoomChannel do
        use MyAppWeb, :channel

        # 跟踪最后一条消息的时间
        @impl true
        def handle_in("message:new", %{"text" => text}, socket) do
          now = System.system_time(:second)
          last_message = socket.assigns[:last_message_at] || 0

          if now - last_message < 1 do
            # 速率限制：最多每秒 1 条消息
            {:reply, {:error, %{reason: "rate_limited"}}, socket}
          else
            # 处理消息
            case create_message(text, socket) do
              {:ok, message} ->
                broadcast!(socket, "message:new", message)
                {:reply, :ok, assign(socket, :last_message_at, now)}

              {:error, changeset} ->
                {:reply, {:error, %{errors: translate_errors(changeset)}}, socket}
            end
          end
        end
      end

  - name: 实现重新连接逻辑
    agent: elixir-dev
    duration: 30min
    tasks:
      - 处理客户端断开连接
      - 实现指数退避
      - 重新连接后恢复状态
    pattern: |
      // 在客户端 JavaScript 中
      let socket = new Socket("/socket", {
        params: {token: window.userToken},
        reconnectAfterMs: function(tries) {
          // 指数退避：1s, 2s, 4s, 8s, 16s（最大值）
          return Math.min(1000 * Math.pow(2, tries), 16000)
        }
      })

      channel.on("error", () => {
        console.error("Channel 错误")
      })

      channel.on("close", () => {
        console.log("Channel 已关闭")
      })

      // 重新连接时重新加入
      socket.onError(() => {
        console.error("Socket 错误")
      })

      socket.onClose(() => {
        console.log("Socket 已关闭")
      })

  - name: 编写 Channel 测试
    agent: elixir-qa
    duration: 2-3hrs
    test_categories:
      join_tests:
        - 测试成功加入并授权
        - 测试未授权用户的加入拒绝
        - 测试房间参数验证

      message_tests:
        - 测试发送和接收消息
        - 测试消息验证
        - 测试向其他用户广播
        - 测试速率限制

      presence_tests:
        - 测试加入时的用户跟踪
        - 测试在线状态更新
        - 测试用户离开

    pattern: |
      defmodule MyAppWeb.RoomChannelTest do
        use MyAppWeb.ChannelCase

        setup do
          user = user_fixture()
          room = room_fixture()

          {:ok, _, socket} =
            MyAppWeb.UserSocket
            |> socket("user_id", %{current_user_id: user.id})
            |> subscribe_and_join(MyAppWeb.RoomChannel, "room:#{room.id}")

          %{socket: socket, user: user, room: room}
        end

        describe "join/3" do
          test "成功加入房间", %{user: user, room: room} do
            {:ok, _, socket} =
              MyAppWeb.UserSocket
              |> socket("user_id", %{current_user_id: user.id})
              |> subscribe_and_join(MyAppWeb.RoomChannel, "room:#{room.id}")

            assert socket.topic == "room:#{room.id}"
          end

          test "拒绝未授权用户", %{room: room} do
            other_user = user_fixture()

            assert {:error, %{reason: "unauthorized"}} =
              MyAppWeb.UserSocket
              |> socket("user_id", %{current_user_id: other_user.id})
              |> subscribe_and_join(MyAppWeb.RoomChannel, "room:#{room.id}")
          end
        end

        describe "message:new" do
          test "向所有用户广播新消息", %{socket: socket} do
            push(socket, "message:new", %{"text" => "你好!"})

            assert_broadcast "message:new", %{text: "你好!"}
          end

          test "对无效消息返回错误", %{socket: socket} do
            ref = push(socket, "message:new", %{"text" => ""})

            assert_reply ref, :error, %{errors: %{text: _}}
          end

          test "强制执行速率限制", %{socket: socket} do
            # 发送第一条消息
            ref1 = push(socket, "message:new", %{"text" => "消息 1"})
            assert_reply ref1, :ok

            # 尝试立即发送第二条消息
            ref2 = push(socket, "message:new", %{"text" => "消息 2"})
            assert_reply ref2, :error, %{reason: "rate_limited"}
          end
        end

        describe "输入事件" do
          test "向其他用户广播 typing:start", %{socket: socket, user: user} do
            push(socket, "typing:start", %{})

            assert_broadcast "typing:start", %{user_id: ^user.id}
          end

          test "向其他用户广播 typing:stop", %{socket: socket, user: user} do
            push(socket, "typing:stop", %{})

            assert_broadcast "typing:stop", %{user_id: ^user.id}
          end
        end

        describe "在线状态" do
          test "加入时跟踪用户", %{socket: socket, user: user} do
            # 在线状态在 :after_join 中被跟踪
            assert_push "presence_state", state

            assert Map.has_key?(state, to_string(user.id))
          end

          test "用户离开时广播在线状态差异" do
            user2 = user_fixture()
            room = room_fixture()

            {:ok, _, socket2} =
              MyAppWeb.UserSocket
              |> socket("user_id", %{current_user_id: user2.id})
              |> subscribe_and_join(MyAppWeb.RoomChannel, "room:#{room.id}")

            # 离开 channel
            Process.unlink(socket2.channel_pid)
            GenServer.stop(socket2.channel_pid)

            assert_broadcast "presence_diff", %{leaves: leaves}
            assert Map.has_key?(leaves, to_string(user2.id))
          end
        end
      end

  - name: 添加监控
    agent: elixir-dev
    duration: 30min
    tasks:
      - 跟踪连接用户数
      - 监控消息吞吐量
      - 设置错误警报
    pattern: |
      # 添加 Telemetry 事件
      defmodule MyAppWeb.RoomChannel do
        def join("room:" <> room_id, _params, socket) do
          :telemetry.execute(
            [:my_app, :channel, :join],
            %{count: 1},
            %{room_id: room_id}
          )

          # ... join 逻辑的其余部分
        end

        def handle_in("message:new", params, socket) do
          start_time = System.monotonic_time()

          result = process_message(params, socket)

          duration = System.monotonic_time() - start_time

          :telemetry.execute(
            [:my_app, :channel, :message],
            %{duration: duration},
            %{room_id: socket.assigns.room_id}
          )

          result
        end
      end

  - name: 质量验证
    agent: elixir-qa
    duration: 30min - 1hr
    checks:
      - Channel 加入正常工作
      - 消息成功广播
      - 在线状态跟踪准确
      - 速率限制有效
      - 重新连接顺利进行
      - 负载下性能可接受
    success_criteria:
      - 所有测试通过
      - 可处理 1000+ 并发连接
      - 消息延迟 < 100ms
      - 无内存泄漏

checklist:
  design:
    - [ ] Channel 架构已规划
    - [ ] 主题/房间已定义
    - [ ] 事件已记录
    - [ ] 身份验证策略已决定

  implementation:
    - [ ] Channel 已生成并配置
    - [ ] Socket 身份验证正常工作
    - [ ] join/3 带授权
    - [ ] 所有事件的 handle_in
    - [ ] 广播已实现
    - [ ] 在线状态跟踪（如需要）
    - [ ] 客户端 JavaScript 正常工作

  features:
    - [ ] 实时消息传递正常工作
    - [ ] 输入指示器（如需要）
    - [ ] 在线状态跟踪（如需要）
    - [ ] 速率限制已就位
    - [ ] 重新连接逻辑正常工作

  testing:
    - [ ] 加入测试通过
    - [ ] 消息测试全面
    - [ ] 在线状态测试正常工作
    - [ ] 速率限制已测试
    - [ ] 已进行负载测试

  production:
    - [ ] 监控已就位
    - [ ] 连接限制已设置
    - [ ] 错误处理健壮
    - [ ] 文档完整

best_practices:
  - "始终在 join/3 中授权"
  - "使用 broadcast! 向所有用户发送消息"
  - "使用 broadcast_from! 排除发送者"
  - "实现速率限制以防止滥用"
  - "优雅地处理重新连接"
  - "跟踪在线状态以获取在线/离线状态"
  - "监控连接数和消息吞吐量"
  - "使用现实负载进行测试"

common_use_cases:
  chat_application:
    - "实时消息传递"
    - "输入指示器"
    - "在线状态"
    - "消息历史"

  collaborative_editing:
    - "文档更新"
    - "光标位置"
    - "用户在线状态"
    - "冲突解决"

  notifications:
    - "用户特定通知"
    - "系统广播"
    - "Toast 消息"

  live_updates:
    - "仪表板指标"
    - "订单状态"
    - "股票价格"
    - "体育比分"

estimated_time: 4-8 小时（取决于复杂性和功能）
