# 任务：创建用户故事

**目的**：创建结构良好的用户故事来指导开发工作

**代理**：elixir-sm

**时长**：15-30 分钟

## 概述

用户故事从用户的角度捕捉功能需求，并将工作分解为可管理、可测试的单元。

## 步骤

### 1. 收集需求

**向利益相关者提出的问题：**
- 用户是谁？（角色、人物角色）
- 他们想要完成什么？（目标）
- 他们为什么需要这个？（价值、业务影响）
- 边界情况是什么？
- 性能要求是什么？
- 安全考虑是什么？

### 2. 按标准格式编写故事

```
作为一个 [角色]
我想要 [操作]
以便 [好处]
```

**示例：**
```
作为一个客户
我想要搜索可用的预约时间段
以便我可以在方便的时间预约

```

### 3. 定义验收标准

使用 **Given-When-Then** 格式编写可测试的标准：

```
Given [初始上下文]
When [操作发生]
Then [预期结果]
```

**示例：**
```
Given 我在预约页面上
When 我搜索特定日期的时间段
Then 我看到该日期的所有可用时间段
And 时间段按时间排序
And 完全预订的时间段不显示
```

### 4. 分解为技术任务

识别实现任务：

**对于 Phoenix 上下文：**
- [ ] 创建上下文模块（如果是新域）
- [ ] 添加 schema 和迁移
- [ ] 实现上下文函数
- [ ] 为上下文编写单元测试

**对于 LiveView 功能：**
- [ ] 创建 LiveView 模块
- [ ] 实现 mount/handle_event
- [ ] 使用流构建模板
- [ ] 添加 LiveView 测试

**对于 API 端点：**
- [ ] 定义路由
- [ ] 创建控制器操作
- [ ] 添加请求验证
- [ ] 编写控制器测试

**对于后台作业：**
- [ ] 创建 GenServer 或 Oban worker
- [ ] 实现业务逻辑
- [ ] 添加错误处理
- [ ] 编写进程测试

### 5. 估计复杂性

使用 T 恤尺寸：
- **XS** (< 2 小时)：简单 CRUD、次要 UI 更改
- **S** (2-4 小时)：单个上下文功能、基本 LiveView
- **M** (4-8 小时)：多个上下文交互、复杂 LiveView
- **L** (1-2 天)：新的有界上下文、主要架构
- **XL** (2+ 天)：分解为更小的故事！

### 6. 识别依赖关系

文档化：
- 所需的数据库迁移
- 对其他故事的依赖
- 外部服务集成
- 基础设施需求（PubSub、缓存等）

### 7. 添加非功能性需求

指定：
- **性能**：响应时间、查询限制
- **安全**：授权、数据验证
- **可扩展性**：预期负载、并发用户
- **可观测性**：日志、指标、警报

### 8. 创建故事文件

保存为 `stories/STORY-###.md`：

```markdown
# STORY-123：搜索可用的预约时间段

**状态**：📝 准备开发
**大小**：M (4-8 小时)
**代理**：elixir-dev
**优先级**：高

## 用户故事

作为一个客户
我想要搜索可用的预约时间段
以便我可以在方便的时间预约

## 验收标准

- [ ] Given 我在预约页面上
      When 我搜索特定日期的时间段
      Then 我看到该日期的所有可用时间段
      And 时间段按时间排序
      And 完全预订的时间段不显示

- [ ] Given 我选择一个时间段
      When 我点击"预约"
      Then 该时间段被保留 10 分钟
      And 我被重定向到预约表单

- [ ] Given 没有可用的时间段
      When 我搜索一个日期
      Then 我看到"此日期没有可用的预约"
      And 我看到一个链接查看下一个可用日期

## 技术任务

- [ ] 创建 `Appointments.list_available_slots/2` 函数
- [ ] 添加具有适当索引的数据库查询
- [ ] 实现具有过期时间的时间段预留逻辑
- [ ] 创建 `AppointmentLive.Search` LiveView
- [ ] 在预订时间段时通过 PubSub 添加实时更新
- [ ] 编写综合测试（上下文 + LiveView）

## 依赖关系

- STORY-120：预约 schema 必须存在
- 用于时间段预留时间戳的数据库迁移

## 非功能性需求

**性能：**
- 搜索查询必须在 < 100ms 内完成
- 支持 100 个并发用户搜索

**安全：**
- 用户只能看到其允许位置的时间段
- 验证所有日期输入以防止注入

## 注释

- 时间段每 30 秒通过 LiveView 刷新一次
- 考虑按位置缓存可用时间段
- 监控时间段可用性检查中的 N+1 查询
```

## 故事检查清单

在将故事标记为准备就绪之前：

- [ ] 用户故事遵循"作为...我想要...以便"格式
- [ ] 验收标准具体且可测试
- [ ] 技术任务已识别和范围确定
- [ ] 提供了大小估计
- [ ] 依赖关系已记录
- [ ] 指定了非功能性需求
- [ ] 考虑了边界情况
- [ ] 审查了安全影响

## 常见故事模式

### CRUD 操作故事
```
作为一个 [用户]
我想要创建/更新/删除 [资源]
以便我可以管理 [域概念]

任务：
- 上下文函数（创建/更新/删除）
- Schema 和 changeset 验证
- 新字段的迁移
- LiveView 表单或 API 端点
- 快乐路径和错误的测试
```

### 实时功能故事
```
作为一个 [用户]
我想要在 [事件发生] 时看到实时更新
以便我拥有当前信息

任务：
- LiveView 中的 PubSub 主题订阅
- 上下文中变更后的广播
- 实时更新的 handle_info
- 乐观 UI 更新
- 并发更新的测试
```

### 后台处理故事
```
作为一个 [用户]
我想要 [系统] 自动 [操作]
以便我不必手动 [任务]

任务：
- 创建 GenServer 或 Oban job
- 实现业务逻辑
- 安排作业（cron 或基于触发器）
- 错误处理和重试
- 监控和警报
```

## 要避免的反模式

❌ **模糊的验收标准**
```
"搜索应该工作良好" ← 不可测试！
```
✅ **具体的验收标准**
```
"搜索在 < 100ms 内为最多 10,000 条记录返回结果"
```

❌ **太大（史诗级）**
```
"构建整个预约预订系统" ← 分解它！
```
✅ **大小合适的故事**
```
"添加可用预约时间段的搜索"
```

❌ **伪装成故事的技术任务**
```
"向预约表添加索引" ← 这是一个任务，不是故事
```
✅ **以用户为中心的故事**
```
"加快预约搜索速度" ← 用户好处清晰
```

## 模板

### 功能故事模板
```markdown
# STORY-###：[简短标题]

**状态**：📝 准备 / 🏗️ 进行中 / ✅ 完成
**大小**：XS/S/M/L/XL
**代理**：elixir-dev/elixir-qa/elixir-architect
**优先级**：高/中/低

## 用户故事
作为一个 [角色]
我想要 [操作]
以便 [好处]

## 验收标准
- [ ] Given...When...Then...

## 技术任务
- [ ] 任务 1
- [ ] 任务 2

## 依赖关系
- STORY-###：描述

## 非功能性需求
**性能**：...
**安全**：...
```

### 错误修复故事模板
```markdown
# STORY-###：修复 [问题]

**状态**：📝 准备
**大小**：XS/S/M
**代理**：elixir-dev
**优先级**：高（如果是生产问题）

## 问题
当前行为：...
预期行为：...
错误消息/堆栈跟踪：...

## 根本原因
[分析错误存在的原因]

## 解决方案
[如何修复它]

## 任务
- [ ] 编写重现错误的失败测试
- [ ] 实现修复
- [ ] 验证所有测试通过
- [ ] 部署到暂存环境并验证

## 预防
[如何防止将来出现类似错误]
```

## 后续步骤

创建故事后：
1. 与团队/利益相关者审查
2. 分配给适当的代理（elixir-dev、elixir-architect 等）
3. 移至"准备开发"状态
4. 在故事文件中跟踪进度
5. 在标记为完成前运行 QA 门
