# BMAD 工作流：添加 REST API 端点
# 在向 Phoenix 添加 JSON API 端点时使用此工作流

name: 添加 REST API 端点
description: 实现 RESTful JSON API 端点的完整工作流
type: feature
framework: phoenix_api
complexity: medium
agents_involved:
  - elixir-dev
  - phoenix-expert
  - ecto-specialist
  - elixir-qa

prerequisites:
  - 已安装 Phoenix 并支持 JSON API
  - 存在要公开的数据的上下文和模式
  - 理解 RESTful 约定
  - 已决定 API 身份验证策略

steps:
  - name: 规划 API 设计
    agent: elixir-dev
    duration: 30min - 1hr
    questions:
      - 要公开哪些资源？
      - 需要哪些 HTTP 方法？(GET, POST, PUT, PATCH, DELETE)
      - 需要什么身份验证/授权？
      - 响应中应包含哪些数据？
      - 需要分页吗？过滤？排序？
      - 版本控制策略是什么？
    deliverable: API 端点规范

  - name: 设计 JSON 响应结构
    agent: elixir-dev
    duration: 15-30min
    considerations:
      - 遵循 JSON:API 规范还是自定义格式？
      - 包含元数据（分页、计数）吗？
      - 错误响应格式
      - 字段命名约定（camelCase vs snake_case）
    example_response: |
      {
        "data": {
          "id": 123,
          "type": "product",
          "attributes": {
            "name": "Widget",
            "price": "9.99",
            "sku": "WID-001"
          },
          "relationships": {
            "category": {
              "data": {"id": 5, "type": "category"}
            }
          }
        },
        "meta": {
          "total_count": 42
        }
      }

  - name: 创建 JSON 视图
    agent: phoenix-expert
    duration: 30min - 1hr
    tasks:
      - 在 lib/my_app_web/controllers/api/ 中创建视图模块
      - 为不同的操作实现渲染函数
      - 处理错误和验证失败
      - 如果需要，包含分页元数据
    pattern: |
      defmodule MyAppWeb.API.ProductJSON do
        alias MyApp.Catalog.Product

        def index(%{products: products, meta: meta}) do
          %{
            data: for(product <- products, do: data(product)),
            meta: meta
          }
        end

        def show(%{product: product}) do
          %{data: data(product)}
        end

        def error(%{changeset: changeset}) do
          %{errors: translate_errors(changeset)}
        end

        defp data(%Product{} = product) do
          %{
            id: product.id,
            type: "product",
            attributes: %{
              name: product.name,
              price: product.price,
              sku: product.sku,
              active: product.active
            },
            inserted_at: product.inserted_at,
            updated_at: product.updated_at
          }
        end

        defp translate_errors(changeset) do
          Ecto.Changeset.traverse_errors(changeset, fn {msg, opts} ->
            Regex.replace(~r"%{(\w+)}", msg, fn _, key ->
              opts |> Keyword.get(String.to_existing_atom(key), key) |> to_string()
            end)
          end)
        end
      end

  - name: 实现控制器
    agent: phoenix-expert
    duration: 1-2hrs
    tasks:
      - 在 lib/my_app_web/controllers/api/ 中创建控制器
      - 实现 RESTful 操作（index、show、create、update、delete）
      - 添加用于错误处理的回退控制器
      - 返回正确的 HTTP 状态码
      - 处理分页和过滤
    pattern: |
      defmodule MyAppWeb.API.ProductController do
        use MyAppWeb, :controller

        alias MyApp.Catalog
        alias MyApp.Catalog.Product

        action_fallback MyAppWeb.FallbackController

        def index(conn, params) do
          page = Map.get(params, "page", "1") |> String.to_integer()
          per_page = Map.get(params, "per_page", "20") |> String.to_integer()
          filters = Map.get(params, "filters", %{})

          with {:ok, result} <- Catalog.list_products_paginated(filters, page, per_page) do
            meta = %{
              page: page,
              per_page: per_page,
              total_count: result.total_count,
              total_pages: result.total_pages
            }

            conn
            |> put_status(:ok)
            |> render(:index, products: result.entries, meta: meta)
          end
        end

        def show(conn, %{"id" => id}) do
          with {:ok, product} <- Catalog.get_product(id) do
            conn
            |> put_status(:ok)
            |> render(:show, product: product)
          end
        end

        def create(conn, %{"product" => product_params}) do
          with {:ok, %Product{} = product} <- Catalog.create_product(product_params) do
            conn
            |> put_status(:created)
            |> put_resp_header("location", ~p"/api/products/#{product}")
            |> render(:show, product: product)
          end
        end

        def update(conn, %{"id" => id, "product" => product_params}) do
          with {:ok, product} <- Catalog.get_product(id),
               {:ok, %Product{} = product} <- Catalog.update_product(product, product_params) do
            conn
            |> put_status(:ok)
            |> render(:show, product: product)
          end
        end

        def delete(conn, %{"id" => id}) do
          with {:ok, product} <- Catalog.get_product(id),
               {:ok, %Product{}} <- Catalog.delete_product(product) do
            send_resp(conn, :no_content, "")
          end
        end
      end

  - name: 创建回退控制器
    agent: phoenix-expert
    duration: 15-30min
    tasks:
      - 为错误处理创建回退控制器
      - 处理常见错误（not_found、validation、unauthorized）
      - 返回一致的错误响应
    pattern: |
      defmodule MyAppWeb.FallbackController do
        use MyAppWeb, :controller

        def call(conn, {:error, :not_found}) do
          conn
          |> put_status(:not_found)
          |> put_view(json: MyAppWeb.ErrorJSON)
          |> render(:"404")
        end

        def call(conn, {:error, :unauthorized}) do
          conn
          |> put_status(:forbidden)
          |> put_view(json: MyAppWeb.ErrorJSON)
          |> render(:"403")
        end

        def call(conn, {:error, %Ecto.Changeset{} = changeset}) do
          conn
          |> put_status(:unprocessable_entity)
          |> put_view(json: MyAppWeb.ChangesetJSON)
          |> render(:error, changeset: changeset)
        end
      end

  - name: 添加路由
    agent: phoenix-expert
    duration: 15min
    tasks:
      - 在 router.ex 中的 /api 作用域中添加路由
      - 使用正确的管道（:api，而不是 :browser）
      - 分组相关资源
      - 考虑 API 版本控制（例如 /api/v1/）
    pattern: |
      scope "/api", MyAppWeb.API, as: :api do
        pipe_through :api

        # 可选：添加身份验证
        # pipe_through :require_api_token

        resources "/products", ProductController, except: [:new, :edit]
        resources "/categories", CategoryController, only: [:index, :show]

        # 自定义路由
        get "/products/:id/related", ProductController, :related
        post "/products/:id/publish", ProductController, :publish
      end

  - name: 实现请求验证
    agent: elixir-dev
    duration: 30min - 1hr
    tasks:
      - 验证请求参数
      - 使用 Ecto.Changeset 进行输入验证
      - 返回清晰的验证错误
      - 处理缺失的必需字段
    pattern: |
      # 在上下文中
      def create_product(attrs) do
        %Product{}
        |> Product.changeset(attrs)
        |> Repo.insert()
      end

      # 在模式中
      def changeset(product, attrs) do
        product
        |> cast(attrs, [:name, :price, :sku, :category_id])
        |> validate_required([:name, :price, :sku])
        |> validate_number(:price, greater_than: 0)
        |> unique_constraint(:sku)
        |> foreign_key_constraint(:category_id)
      end

  - name: 添加身份验证（如果需要）
    agent: elixir-dev
    duration: 1-2hrs
    strategies:
      api_token:
        - "使用 Bearer 令牌身份验证"
        - "在数据库或 JWT 中存储令牌"
        - "在插件管道中验证令牌"

      oauth:
        - "使用 OAuth2 进行第三方访问"
        - "实现授权代码流"
        - "返回访问和刷新令牌"

    pattern: |
      # 令牌身份验证插件
      defmodule MyAppWeb.Plugs.APIAuth do
        import Plug.Conn

        def init(opts), do: opts

        def call(conn, _opts) do
          with ["Bearer " <> token] <- get_req_header(conn, "authorization"),
               {:ok, user} <- verify_token(token) do
            assign(conn, :current_user, user)
          else
            _ ->
              conn
              |> put_status(:unauthorized)
              |> put_view(json: MyAppWeb.ErrorJSON)
              |> Phoenix.Controller.render(:"401")
              |> halt()
          end
        end

        defp verify_token(token) do
          # 验证令牌并返回用户
          MyApp.Accounts.verify_api_token(token)
        end
      end

      # 在路由器中
      pipeline :api_authenticated do
        plug :api
        plug MyAppWeb.Plugs.APIAuth
      end

  - name: 实现分页
    agent: ecto-specialist
    duration: 30min - 1hr
    tasks:
      - 向上下文函数添加分页
      - 返回总计数和页面元数据
      - 支持 page 和 per_page 参数
      - 添加限制以防止过多结果
    pattern: |
      def list_products_paginated(filters, page \\\\ 1, per_page \\\\ 20) do
        # 将 per_page 限制为合理的最大值
        per_page = min(per_page, 100)
        offset = (page - 1) * per_page

        query = from p in Product, where: p.active == true
        query = apply_filters(query, filters)

        products =
          query
          |> limit(^per_page)
          |> offset(^offset)
          |> Repo.all()

        total_count = Repo.aggregate(query, :count)

        {:ok, %{
          entries: products,
          page_number: page,
          page_size: per_page,
          total_entries: total_count,
          total_pages: ceil(total_count / per_page)
        }}
      end

  - name: 添加过滤和排序
    agent: ecto-specialist
    duration: 30min - 1hr
    tasks:
      - 支持用于过滤的查询参数
      - 允许按多个字段排序
      - 验证过滤和排序参数
      - 使用动态查询以获得灵活性
    pattern: |
      def list_products(filters) do
        Product
        |> apply_filters(filters)
        |> apply_sorting(filters["sort_by"], filters["sort_order"])
        |> Repo.all()
      end

      defp apply_filters(query, filters) do
        Enum.reduce(filters, query, fn
          {"active", value}, query when value in ["true", "false"] ->
            where(query, [p], p.active == ^(value == "true"))

          {"category_id", value}, query ->
            where(query, [p], p.category_id == ^value)

          {"min_price", value}, query ->
            where(query, [p], p.price >= ^value)

          {"search", value}, query ->
            search_term = "%#{value}%"
            where(query, [p], ilike(p.name, ^search_term))

          _, query ->
            query
        end)
      end

      defp apply_sorting(query, nil, _), do: order_by(query, [desc: :inserted_at])
      defp apply_sorting(query, field, "asc"), do: order_by(query, [asc: ^field])
      defp apply_sorting(query, field, _), do: order_by(query, [desc: ^field])

  - name: 编写 API 测试
    agent: elixir-qa
    duration: 2-3hrs
    test_categories:
      index_tests:
        - 测试返回资源列表
        - 测试分页是否正常工作
        - 测试过滤是否有效
        - 测试空结果处理

      show_tests:
        - 测试返回单个资源
        - 测试未找到时返回 404

      create_tests:
        - 测试使用有效数据创建（201 状态）
        - 测试验证错误（422 状态）
        - 测试未授权（401 状态）

      update_tests:
        - 测试使用有效数据更新
        - 测试验证错误
        - 测试资源未找到时返回 404

      delete_tests:
        - 测试删除资源（204 状态）
        - 测试未找到时返回 404

    pattern: |
      defmodule MyAppWeb.API.ProductControllerTest do
        use MyAppWeb.ConnCase

        import MyApp.CatalogFixtures

        @create_attrs %{name: "Widget", price: "9.99", sku: "WID-001"}
        @update_attrs %{name: "Updated Widget", price: "12.99"}
        @invalid_attrs %{name: nil, price: nil}

        setup %{conn: conn} do
          {:ok, conn: put_req_header(conn, "accept", "application/json")}
        end

        describe "index" do
          test "lists all products", %{conn: conn} do
            product = product_fixture()
            conn = get(conn, ~p"/api/products")

            assert json_response(conn, 200)["data"] == [
              %{
                "id" => product.id,
                "type" => "product",
                "attributes" => %{
                  "name" => product.name,
                  "price" => to_string(product.price),
                  "sku" => product.sku
                }
              }
            ]
          end

          test "supports pagination", %{conn: conn} do
            # 创建 25 个产品
            for i <- 1..25, do: product_fixture(name: "Product #{i}")

            conn = get(conn, ~p"/api/products?page=2&per_page=10")
            response = json_response(conn, 200)

            assert length(response["data"]) == 10
            assert response["meta"]["page"] == 2
            assert response["meta"]["total_pages"] == 3
          end

          test "supports filtering", %{conn: conn} do
            active = product_fixture(active: true, name: "Active")
            _inactive = product_fixture(active: false, name: "Inactive")

            conn = get(conn, ~p"/api/products?filters[active]=true")
            data = json_response(conn, 200)["data"]

            assert length(data) == 1
            assert hd(data)["attributes"]["name"] == "Active"
          end
        end

        describe "show" do
          test "renders product when found", %{conn: conn} do
            product = product_fixture()
            conn = get(conn, ~p"/api/products/#{product.id}")

            assert %{
              "id" => ^product.id,
              "type" => "product"
            } = json_response(conn, 200)["data"]
          end

          test "renders 404 when not found", %{conn: conn} do
            conn = get(conn, ~p"/api/products/999")
            assert json_response(conn, 404)
          end
        end

        describe "create" do
          test "creates product with valid data", %{conn: conn} do
            conn = post(conn, ~p"/api/products", product: @create_attrs)

            assert %{"id" => id} = json_response(conn, 201)["data"]

            conn = get(conn, ~p"/api/products/#{id}")
            assert %{
              "id" => ^id,
              "attributes" => %{
                "name" => "Widget",
                "price" => "9.99",
                "sku" => "WID-001"
              }
            } = json_response(conn, 200)["data"]
          end

          test "renders errors with invalid data", %{conn: conn} do
            conn = post(conn, ~p"/api/products", product: @invalid_attrs)

            assert json_response(conn, 422)["errors"] != %{}
          end
        end

        describe "update" do
          test "updates product with valid data", %{conn: conn} do
            product = product_fixture()
            conn = put(conn, ~p"/api/products/#{product.id}", product: @update_attrs)

            assert %{"id" => id} = json_response(conn, 200)["data"]

            conn = get(conn, ~p"/api/products/#{id}")
            assert %{
              "attributes" => %{
                "name" => "Updated Widget",
                "price" => "12.99"
              }
            } = json_response(conn, 200)["data"]
          end
        end

        describe "delete" do
          test "deletes chosen product", %{conn: conn} do
            product = product_fixture()
            conn = delete(conn, ~p"/api/products/#{product.id}")

            assert response(conn, 204)

            conn = get(conn, ~p"/api/products/#{product.id}")
            assert json_response(conn, 404)
          end
        end
      end

  - name: 添加 API 文档
    agent: elixir-dev
    duration: 30min - 1hr
    tasks:
      - 记录所有端点
      - 包含请求/响应示例
      - 记录身份验证要求
      - 添加错误响应示例
    tools:
      - OpenAPI/Swagger 规范
      - Phoenix Swagger 库
      - README 文档

  - name: 质量验证
    agent: elixir-qa
    duration: 30min - 1hr
    checks:
      - 所有 API 测试通过
      - 返回正确的 HTTP 状态码
      - 错误响应一致
      - 身份验证正常工作
      - 分页已测试
      - 大型数据集的性能可接受
    success_criteria:
      - 所有测试通过
      - 没有 N+1 查询
      - 响应时间 < 200ms
      - 正确的错误处理

checklist:
  design:
    - [ ] API 端点已规划（资源、方法）
    - [ ] JSON 响应结构已定义
    - [ ] 身份验证策略已决定
    - [ ] 分页/过滤要求清晰

  implementation:
    - [ ] JSON 视图已实现，具有正确的结构
    - [ ] 控制器操作遵循 RESTful 约定
    - [ ] 回退控制器处理错误
    - [ ] 路由已添加到 /api 作用域，带有 :api 管道
    - [ ] 在 changesets 中进行请求验证
    - [ ] 正确的 HTTP 状态码（200、201、204、404、422 等）

  features:
    - [ ] 分页已实现（如果需要）
    - [ ] 过滤正常工作（如果需要）
    - [ ] 排序已实现（如果需要）
    - [ ] 身份验证正常工作（如果需要）
    - [ ] 授权检查已就位

  testing:
    - [ ] 所有 CRUD 操作已测试
    - [ ] 分页已测试
    - [ ] 过滤已测试
    - [ ] 错误情况已覆盖
    - [ ] 身份验证已测试（如果适用）

  documentation:
    - [ ] API 端点已记录
    - [ ] 提供了请求/响应示例
    - [ ] 身份验证要求清晰
    - [ ] 错误响应已记录

http_status_codes:
  success:
    - "200 OK - 成功的 GET、PUT/PATCH"
    - "201 Created - 成功的 POST"
    - "204 No Content - 成功的 DELETE"

  client_errors:
    - "400 Bad Request - 无效的请求格式"
    - "401 Unauthorized - 缺失/无效的身份验证"
    - "403 Forbidden - 有效的身份验证但权限不足"
    - "404 Not Found - 资源不存在"
    - "422 Unprocessable Entity - 验证失败"

  server_errors:
    - "500 Internal Server Error - 意外错误"
    - "503 Service Unavailable - 临时不可用"

best_practices:
  - "使用正确的 HTTP 状态码"
  - "返回一致的错误格式"
  - "在 changesets 中验证所有输入"
  - "限制分页页面大小（最大 100）"
  - "使用回退控制器进行错误处理"
  - "对 API 进行版本控制（/api/v1/）"
  - "记录所有端点"
  - "彻底测试，包括错误情况"

estimated_time: 4-8 hours (取决于复杂性和功能)
